// 1. 자바스크립트는 웹의 프로그래밍 언어입니다.
// 웹 사이트의 절대 다수가 자바스크립트를 사용하며, 데스크톱과 테블릿, 스마트폰에서 동작하는 최신 웹 브라우저는
// 모두 자바스크립트 인터프리터를 내장하고 있습니다.

// 자바스크립트 인터프리터는 자바스크립트 소스 코드를 바로 실행하는 컴퓨터 프로그램이나 환경을 말합니다.
// 자바스크립트는 기본적으로 인터프리터 언어로, 웹 브라우저에서 주로 사용되며, 서버 프로그래밍에도 사용됩니다.
// 인터프리터는 원시 코드를 기계어로 변환하지 않고 한 줄씩 해석하여 바로 명령어를 실행하는 프로그램입니다.

// 자바스크립트 변수에는 타입이 없습니다. 그래서 보통 자바스크립트를 동적 언어(Dynamic Language)라고 표현하고 있습니다.
// 자바스크립트라는 이름 때문에 오해의 소지가 있을 수 있는데요. 자바스크립트 몇 가지 문법이 자바에서 차용한 것은 맞지만,
// 이를 제외하면 두 언어 사이에는 별 다른 관련이 없습니다. 자바라는 언어와는 확실히 다른 언어라는 점이죠.

// 자바스크립트도 프로그래밍 언어이기 때문에 이 언어로 프로그램을 만들 때 지켜야 할 기본적인 규칙이 있습니다.
// 변수 이름은 어떻게 지어야 하는지, 주석은 어떻게 만드는 지, 문과 문을 어떻게 구분하는지 등을 결정짓는 것들을
// 프로그래밍 언어의 어휘 구조라고 하는데요. 자바스크립트에서는 어떤 어휘 구조를 사용하는지 같이 살펴보도록 하겠습니다.

// ----------------------------------------------------------------------------------------------------

// 1.1 식별자
// 식별자는 이름입니다. 자바스크립트에서 식별자는 상수, 변수, 프로퍼티, 함수, 클래스의 이름에 사용하고 일부 루프의 라벨로도 사용됩니다.
// 식별자는 반드시 글자(알파벳 사용을 권장합니다.), 밑줄(_), 달러 기호($)로 시작을 해야합니다.
// 이 뒤에는 글자, 숫자, 밑줄, 달러 기호를 사용할 수 있습니다.
// 식별자 가장 첫 번째 자리에 숫자를 허용하지 않는 이유는 자바스크립트에서 식별자와 숫자를 쉽게 구별하기 위해서 입니다.
// 물론, 공백문자 역시 식별자에 사용할 수 없습니다.

// 식별자의 길이를 딱히 제한하고 있진 않습니다. 다만, 너무 길게 작성하면 협업을 할 경우 혹은 혼자 작업을 하더라도
// 긴 네이밍 때문에 해당 식별자가 정확히 어떤 역할을 하는지 파악하기 어려울 수 있기 때문에
// 가급적 간결하고, 명확하게 작성해주시는 게 좋습니다.

// let: 키워드, age: 식별자, 30: 데이터
let age = 30;

// 자바스크립트는 대소문자를 구분하기 때문에 아래 두 식별자는 다른 식별자로 취급합니다.
let myFavorite;
let myfavorite;

// 자바스크립트의 예약어도 식별자로 사용할 수 없습니다.
// 예) let, const, if, else, function, import, this, from, class 등...

// ----------------------------------------------------------------------------------------------------

// 1.2 선택 사항인 세미콜론
// 자바스크립트 역시 다른 프로그래밍 언어와 마찬가지로 세미콜론(;)을 사용해 문을 구분합니다.
// 세미콜론은 코드의 의미를 명확히 하는데 중요한 역할을 한다.
// 구분자가 없다면 어떤 문의 끝과 다른 문의 시작을 구분하기가 쉽지 않기 때문에 보통 세미콜론(;)을 사용한다.

// 자바스크립트에서 두 문 사이에 줄바꿈이 있을 때는 대부분 세미콜론(;)을 생략하곤 한다.

// ----------------------------------------------------------------------------------------------------

// 1.3. 변수 선언과 할당
// 이름 또는 식별자를 사용해 값을 표현하는 것은 컴퓨터 프로그래밍의 가장 기본적인 기술 중 하나입니다.
// 값에 이름을 부여하면 프로그램에서 그 값을 참조하고 사용할 수 있습니다.
// 이런 과정을 일반적으로 변수에 값을 할당한다고 말합니다.
// 따라서 변수라는 용어는 새로운 값을 할당할 수 있음을 암시합니다. 즉, 프로그램이 실행됨에 따라 변수에 연결된 값이 바뀔 수 있습니다.
// 값에 이름을 영구히 할당할 때는 변수 대신 상수라고 부릅니다.

// 1.3.1 let과 const를 사용한 선언
// 변수를 선언할 땐, let 키워드를 사용합니다.
let i;
let sum;

// 가능하면 다음과 같이 변수를 선언할 때, 초깃값을 할당하는 것이 좋은 프로그래밍 습관입니다.
let message = "Hello, World!";
let x = 10;
let y = x * x;

// let 문에서 변수에 초깃값을 할당하지 않으면 값을 할당할 때까지 undefined로 남습니다.

// 상수를 선언할 때는 const를 사용합니다.
// const는 let과 거의 비슷하지만, 선언할 때 반드시 값을 할당해 초기화해야 한다는 점이 다릅니다.
const name; // 'const' 선언을 초기화해야 합니다.ts(1155)

// 이름에서 짐작할 수 있듯 상수의 값은 바꿀 수 없습니다.
// 반드시 지켜야 하는 건 아니지만, 상수를 선언할 때는 전부 대문자를 써서 변수와 구별하는 관습이 있습니다.

// const 키워드는 자바스크립트에서 [변수 자체에 재할당을 방지하는 역할]을 합니다.
// 하지만 const로 선언한 객체나 배열의 내용물(프로퍼티나 요소)은 변경할 수 있습니다.
// 이를 이해하기 위해서는 const가 어떻게 동작하는지 좀 더 깊이 파악할 필요가 있는데요.

// 1) const는 '변수 재할당'을 막는다.
// const는 객체 자체나 배열을 다시 할당하는 것을 막습니다. 예를 들어
const user = {
    name: "9Diin",
    email: "9diin@gmail.com",
};
console.log(user); // { name: '9Diin', email: '9diin@gmail.com' }

user = { name: "test", email: "test@test.com" };
console.log(user); // Assignment to constant variable.

// 위 코드에서 user 자체를 다른 객체로 재할당하려고 하면 오류가 발생합니다.
// 하지만 객체 내부의 값을 바꾸는 것은 가능합니다.

// 2) 객체의 프로퍼티는 변경할 수 있다.
// 객체의 프로퍼티 값은 변경할 수 있습니다. 즉, const로 선언된 객체라도 그 객체 내부의 값은 수정이 가능하다.
user.name = "test";
user.email = "test@test.com";
console.log(user);

// user 객체의 속성 값을 바꿀 수 있는 이유는 user라는 변수는 객체의 참조를 가리키고 있기 때문입니다.
// 즉, let과 const 키워드를 통해 임의의 식별자를 선언하면 메모리 주소가 생기고, 그 주소를 참조합니다.
// const로 선언된 상수는 그 객체의 참조(주소)가 바뀌지 않도록 보장할 뿐, 객체 내부의 데이터 자체는 변경할 수 있습니다.

// 배열도 같은 규칙이 적용됩니다.
// 배열을 const로 선언하면 배열 자체를 재할당 할 순 없지만, 배열의 요소를 변경하거나 추가하는 것은 가능합니다.
const users = ["Kim", "Lee", "Park"];
users = ["Choi", "Yoon", "Song"];
console.log(users); // Assignment to constant variable.

users.push("Choi");
console.log(users); // ['Kim', 'Lee', 'Park', 'Choi']

users[0] = "Song";
console.log(users); // ['Song', 'Lee', 'Park', 'Choi']

// const는 객체나 배열이 재할당되는 것을 방지하지만, 그 내용물(프로퍼티나 값, 요소)은 여전히 변경할 수 있습니다.
// const의 목적은 변수의 재할당을 방지하는 것 뿐이지, 불변성을 보장하는 것은 아닙니다.
